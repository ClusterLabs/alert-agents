#!/bin/sh
#
# Copyright 2015-2021 the Pacemaker project contributors
#
# The version control history for this file may have further details.
#
# This source code is licensed under the GNU General Public License version 2
# or later (GPLv2+) WITHOUT ANY WARRANTY.
#
##############################################################################
# This sample script assumes that only users who already have root access can
# edit the CIB. Otherwise, a malicious user can create damage anywhere in the
# filesystem  where user hacluster has access - as well as writing to special
# files.
# If that is not the case in your environment, you should edit this script to
# validate the log-destination.
#
# Sample configuration (cib fragment in xml notation)
# ================================
# <configuration>
#   <alerts>
#     <alert id="alert_sample" path="/path/to/pcmk_alert_sample.sh">
#       <instance_attributes id="config_for_pcmk_alert_sample">
#         <nvpair id="debug_option_1" name="debug_exec_order" value="false"/>
#       </instance_attributes>
#       <meta_attributes id="config_for_timestamp">
#         <nvpair id="ts_fmt" name="timestamp-format" value="%H:%M:%S.%06N"/>
#       </meta_attributes>
#       <recipient id="logfile_destination" value="/path/to/logfile"/>
#     </alert>
#   </alerts>
# </configuration>

if [ -z $CRM_alert_version ]; then
    echo "$0 must be run by Pacemaker version 1.1.15 or later"
    exit 0
fi

# Alert agents must always handle the case where no recipients are defined,
# even if it's a no-op (a recipient might be added to the configuration later).
if [ -z "${CRM_alert_recipient}" ]; then
    echo "$0 requires a recipient configured with a full filename path"
    exit 0
fi

debug_exec_order_default="false"

: ${debug_exec_order=${debug_exec_order_default}}

if [ "${debug_exec_order}" = "true" ]; then
    tstamp=`printf "%04d. " "$CRM_alert_node_sequence"`
    if [ ! -z "$CRM_alert_timestamp" ]; then
        tstamp="${tstamp} $CRM_alert_timestamp (`date "+%H:%M:%S.%06N"`): "
    fi
else
    if [ ! -z "$CRM_alert_timestamp" ]; then
        tstamp="$CRM_alert_timestamp: "
    fi
fi

case $CRM_alert_kind in
    node)
        echo "${tstamp}Node '${CRM_alert_node}' is now '${CRM_alert_desc}'" >> ${CRM_alert_recipient}
        ;;
    fencing)
        # Other keys:
        #
        # CRM_alert_node
        # CRM_alert_task
        # CRM_alert_rc
        #
        echo "${tstamp}Fencing ${CRM_alert_desc}" >> ${CRM_alert_recipient}
        ;;
    resource)
        # Other keys:
        #
        # CRM_alert_target_rc
        # CRM_alert_status
        # CRM_alert_rc
        #
        if [ ${CRM_alert_interval} = "0" ]; then
            CRM_alert_interval=""
        else
            CRM_alert_interval=" (${CRM_alert_interval})"
        fi

        if [ ${CRM_alert_target_rc} = "0" ]; then
            CRM_alert_target_rc=""
        else
            CRM_alert_target_rc=" (target: ${CRM_alert_target_rc})"
        fi

        case ${CRM_alert_desc} in
            Cancelled) ;;
            *)
                echo "${tstamp}Resource operation '${CRM_alert_task}${CRM_alert_interval}' for '${CRM_alert_rsc}' on '${CRM_alert_node}': ${CRM_alert_desc}${CRM_alert_target_rc}" >> ${CRM_alert_recipient}
                ;;
        esac
        ;;
    attribute)
        #
        echo "${tstamp}Attribute '${CRM_alert_attribute_name}' on node '${CRM_alert_node}' was updated to '${CRM_alert_attribute_value}'" >> "${CRM_alert_recipient}"
        ;;
    *)
        echo "${tstamp}Unhandled $CRM_alert_kind alert" >> ${CRM_alert_recipient}
        env | grep CRM_alert >> ${CRM_alert_recipient}
        ;;
esac
